# Developing

Each of the microservices has a README that describes how to build and run the specific microservice.  This document
provides an overview for developing for RoboDomo, in general.

## Microservices

Microservices are intended to be made into Docker containers and run via docker.  However, this is not convenient for
doing development work on a microservice.  There is a debug.sh script in each microservice repository that you can use
to run the microservice in Docker, but not as a deamon.  This allows you to ^C to kill the microservice, as you will
want to restart it over and over again.  It also allows the microservice to console.log() (or similar) generate
debugging output.

The microservices are typically configured via ENV variables.  These are documented in the README for the microservice.

### development scripts

* build.sh - builds a docker container for the microservice
* debug.sh - runs the microservice in Docker, not as a deamon.
* run.sh - runs the microservice in Docker, as a daemon.
* shell.sh - gets you a shell prompt in the Docker container.
* stop.sh - stops a running microservice instance.

Sometimes the environment inside the container is the problem that needs fixing.  The shell.sh script lets you poke
around and see what your microservice app sees, from the container's POV.

If you are not running the microservices on a RoboDomo (Docker) server (yet), you can use the run.sh script to bring up
the microservices you choose.

### MQTT

The entire communication strategy is implemented using MQTT.  The client side uses MQTT to listen for state changes and
to publish set messages to effect a change in the devices being controlled (e.g. turn on power, set volume, set
thermostat set point...).  The microservices (servers) listen for set messages and effect the change in the device they
control.  The microservices publish status messages when they detect a change in the state of the device.

The specifics for monitoring a device or effecting state change of the device is unique to the kind of device and is
encapsulated and hidden by the microservice.  The API is orthagonal - status messages contain state information of the
device, and to control any device a set message is generated by the client (or other microservice).

All of the status messages are retained by the server.  This means that a light switch state change might have happened
an hour ago, but when the client subscribes to the status topic, it will receive the accurate switch state via status
message right away.  Thus the UI can render the switch on or off immediately.

### microservice-core library

The microservices use a common library, microservice-core that is installed via npm in the microservice repositories.

For example, the package.json for appletv-microservice contains:
```
  "dependencies": {
    "debug": "^4.1.1",
    "microservice-core": "github:robodomo/microservice-core",
    "mqtt": "^2.18.8",
    "node-appletv": "github:robodomo/node-appletv"
  }
  ```

The microservice core library provides 3 classes:
* HostBase
* StatefulEmitter
* Mongoose

Currently RoboDomo does not use Mongoose, but the concept is to eventually provide database access for state,
configuration/settings, logging, and to create a record of events to generate reports.

#### StatefulEmitter

StatefulEmitter is a trivial class that is a combination of NodeJS EventEmitter that also has a concept of state,
similar to ReactJS' state.  Rather than calling setState() on the server side, you use the ```set state(value)```
setter.

The setter works similarly to ReactJS' setState().  If you pass a JavaScript Object as the, argument it is merged into
the existing state object.  The this._state variable can be set directly.  

When the setter is called, a "statechange" event is emitted with newState and oldState arguments passed.

The StatefulEmitter class also provides an ```async wait(msecs)``` member that a microservice can call to delay the
specified amount of time.  Typically used within a while(1) loop that is polling for state changes, etc.

#### HostBase

The HostBase class extends StatefulEmitter and provides a consistent API for dealing with MQTT and publishing
topic/messages when state changes.  

It is typical that a microservice is going to deal with multiple "hosts," and HostBase facilitates this.  For example,
you may have more than one LG TV to be controlled by RoboDomo; each is a distinct HostBase instance.  HostBase instances
that control devices will also listen for "set" topics to change the state of the device being controlled.  For example,
the LG TV microservice HostBase instance will listen for "set" topics to turn on the TV, set the HDMI input, and so on.

The HostBase contructor takes three arguments:
* host - the MQTT connection string
* topic - the base topic to be used for listening for "set" messages and to publish "status" messages.
* custom - boolean, if true then the parent/microservice that extends HostBase will handle MQTT messages

HostBase handles reconnect, errors, etc., for the MQTT connection.  It handles incoming messages to the "set" topic and
calls an ```async this.command(topic, message)``` provided by the child class (the microservice HostBase instance).

Since HostBase inherits from StatefulEmitter, it can (and does) listen for statechange messages that are emitted when
the state setter is invoked.  By default (e.g. custom is not true), HostBase iterates through all of the members of the
state Object and publishes status topic/messages only for the values that change.

HostBase provides a ```this.publish(topic, value)``` to directly publish an arbitrary topic/message.

Finally, HostBase provides a ```this.exception(e)``` method that tries to publish the exception as a base topic plus
exception message.

An example HostBase using LG TV...  LG TV microservice extends HostBase and creates an instance for each LG TV in the
configuration file (or ENV var).  The HostBase instance implements ```async command()``` that it expects to be called to
change the state of some aspect of the TV (turn on/off, select HDMI input, launch application, and so on).  The HostBase
instance will then sit in a while(1) loop, doing http request to the TV to get status (e.g. request current volume,
power on/off, currentply playing application, and so on).  When power goes from off to on, it does 
```
state = { power: "on" };
```
This causes, internally, the statechange event to be fired and the HostBase base class sees only the power member has
changed and it will publish a staus/power topic with "on" value.  In the while(1) loop, after the http poll,
```this.wait(500)``` is called to defer the next http poll for half a second (thus the latency for TV turned on to
status message is .5 seconds max).

## Continue Reading

* [Hardware](./Hardware.md)
* [DNS and Routing](./Networking.md)
* [Docker](./Docker.md)
* [MQTT](./MQTT.md)
* [SmartThings MQTT Bridge](./MQTTBridge.md)
* [Speaker / Text to Speech](./RoboSpeak.md)
* [Developing](./Developing.md)

